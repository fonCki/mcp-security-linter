const MCPSecurityLinter = require('../../src/index');
const path = require('path');
const fs = require('fs');
const os = require('os');

describe('MCPSecurityLinter Integration', () => {
  let linter;
  let tempDir;

  beforeEach(() => {
    linter = new MCPSecurityLinter({
      'ai-detector': { enabled: true }
    });

    // Create temp directory with test files (not in fixtures)
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'mcp-test-'));
    fs.writeFileSync(path.join(tempDir, 'test-chatgpt.js'), '// Generated by ChatGPT\nfunction test() {}');
    fs.writeFileSync(path.join(tempDir, 'test-clean.js'), '// Clean file\nfunction clean() {}');
  });

  afterEach(() => {
    // Cleanup temp directory
    if (tempDir && fs.existsSync(tempDir)) {
      fs.rmSync(tempDir, { recursive: true, force: true });
    }
  });

  test('analyzes directory with mixed files', async () => {
    const findings = await linter.analyze(tempDir);

    expect(findings).toBeDefined();
    expect(Array.isArray(findings)).toBe(true);
    expect(findings.length).toBeGreaterThan(0);
  });

  test('returns proper finding structure', async () => {
    const findings = await linter.analyze(tempDir);

    if (findings.length > 0) {
      const finding = findings[0];
      expect(finding).toHaveProperty('ruleId');
      expect(finding).toHaveProperty('level');
      expect(finding).toHaveProperty('message');
      expect(finding).toHaveProperty('location');
      expect(finding.location).toHaveProperty('file');
      expect(finding.location).toHaveProperty('line');
      expect(finding.location).toHaveProperty('column');
    }
  });

  test('respects analyzer configuration', async () => {
    const disabledLinter = new MCPSecurityLinter({
      'ai-detector': { enabled: false }
    });

    const findings = await disabledLinter.analyze(tempDir);

    expect(findings.length).toBe(0);
  });
});